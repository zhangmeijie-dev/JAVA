Throwable类：		java.lang.Throwable
	1：Java中所有异常和错误的超类
	2：具有可抛性
	3：继承体系：
		Throwable				java.lang.Throwable-----------------java中所有异常和错误的超类
							java.lang.Exception---------------------异常类 
Exception类（异常类）	Error类（错误类）			java.lang.Error------------------------错误类

★★★错误（ Error类 ）：一般不是代码层次的问题，没有办法通过修改代码解决，只有避开Error的发生

	例如：   创建一个数组 该数组大于你电脑的内存，但是在其他电脑（内存够大）可以被创建


★★★异常（Exception类）：一般是人为的，可以被处理
	例如：3/0------除数不可以为0   


★★★★注意★★★★
	★★异常（Excption）或错误（Error）一旦抛出就需要进行处理，如果自己没有处理（ try----catch ）而是选择抛出去，那么在异常处理后整个程序将会停止,如果自己处理了，那么异常后面的的程序就会在异常处理后继续执行

	★★在继承中，父类的方法如果抛出了异常那么子类重写该方法可以抛出异常，也可以不抛出异常，如果子类要抛出异常的话抛出的异常不能大过父类的异常；如果父类的方法没有抛出异常那么子类的重写方法不能抛出编译异常，可以抛出运行异常



方法内抛出异常-----throw  抛出异常
方法上抛出异常--------throws  


	★★异常分类：★★
		1：编译异常（Excption）
			★★a：需要程序员对发生的异常进行处理
			★★b：该种异常需要程序员来抛出该种异常（在方法体中使用 throw 关键字抛出异常）
			★★c：必须在编译时期对该种异常进行处理，不然编译不通过

		2：运行时异常(RuntimeExcption)   -----该中异常时Excption类的子类
			★★a：默认是由JVM来创建该种异常，并将该异常抛出给调用者（ 用户也可以自己手动使用throw关键字抛出 ）
			★★b：该类型异常在编译时期可以不进行处理，不进行处理的话JVM会自动的把该类异常抛给调用者
			
				
★★★★★异常的处理：★★★★★★

	1：  throws   异常列表
		格式：   权限修饰符   返回值  方法名（参数列表）throws   异常列表   { 方法体  }
		注意：
		      1：使用在方法的声明上面
		      2：抛出异常的方法自己不进行处理，将他抛给该方法的调用者
		      3：运行时异常（RuntimeExcption）可以不用在进行处理，但是编译异常（Excption）必须要被该处理
		      4：该种处理异常的方法回事该方法中发生异常后的代码无法执行
		补充：
		      该中方法在继承的时候，子类重写该方法，子类的方法可以不抛出异常，但是如果要抛异常的话只能抛出范围比父类方法小的异常
		      

	2：try---catch---finally
	         格式：
		try{  					注意：
		    可能发生异常的代码 。。。。。		      1：使用在方法体中（将发生异常的放在try中）	
		 }catch（异常类型1）{			      2：抛出异常的方法自己对抛出的异常进行处理，不将他抛给调用者
		    捕获的对异常进行处理的过程。。。		      3：一个try--catch---finally最多只能捕获一个异常
		}catch（异常类型2）{				      4：在多个catch的时候，上面的catch捕获的异常类型因该时下面catch捕
		    捕获的对异常进行处理的过程。。。		      获异常的子类（范围小异常在上面）
		} 。					      5：finally不管异常有没有被捕获，他都会执行（在异常捕获结束后执行）
		  。					      6：在try{ 可能发生异常的代码。。。}中，如果某个其中的某个地方抛出
		  。					      异常那么其后的代码就算被捕获处理了也不会执行
		}catch（异常类型n ）{
		    对捕获的异常进行处理
		}finally{
		    不管try体中的异常最后有没有不catch捕获主力，finally中的代码都将执行
		}
	
  
	扩展：
		题目一：
		public int  ABC（）{
			try{
				System.out.println(6/0);-----》抛出运行时异常
				return  1;-----------------------------------》永远不会被执行
			}catch(Excption e){
				System.out.println("有异常，捕获成功！！")；
				return 2;-------------------------------------------》第一个返回给调用者的值
			}finally{
				System.out.println("我来结尾！！！")；
				return 3；-----------------------------------------》第二次返回给调用者的值（会覆盖掉前面返回值）
			}
	
		//	return 4；（编译会出错，应为他永远不会被执行）
		}
		结果：
		    最终该方法会返回3

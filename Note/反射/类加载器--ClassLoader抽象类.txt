类加载器：（ . class 文件）
	将类加载进内存中

类加载器分类：
	根类加载器：----------负责加载Java的核心类   （C语言编写）
	系统类加载器（ExtClassLoader）：-------负责加载java的基础类    （ java语言编写 ）
	应用类加载器（AppClassLoader）：-------负责加载java中的应用类 （ java语言编写 ）

	他们三者之间的关系不是继承关系，而是组合关系

ClassLoader抽象类：

	★★★该类对象是由虚拟机自己创建的，用户无法创建只能获取★★★


方法：
	ClassLoader	getParent(); -----------------返回委托的父类加载器


	URL	getResource（ String ）；-----------查找具有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的一些数据（图像、声音、文本等）。 

			       String ---------相对与src目录下的某个资源的名称
	返回值：
		读取到资源的 URL 对象；如果找不到该资源，或者调用者没有足够的权限获取该资源，则返回 null。


	InputStream	getResourceAsStream ( String );   -------------------返回读取指定资源的输入流。
	返回值：
		获取Src根目录下的指定资源的输入流



获取ClassLoader对象的获取方法：
	方法一：
		Class对象 . getClassLoader ( );
			-----获取指定对象的加载器

	方法二：
		ClassLoader对象  .  getParent ( )；
			--------获取当前加载器的父类加载器
	


补充：
 双亲委托机制：
	类加载器在加载资源时，不会立即加载，而是先交给上一级加载器，一直传递到根类加载器，如果根类加载器可以加载，则由根类加载器来加载，如果不能加载，则交给下一级的加载器来加载，下一集如果不能加载，则在交给下一级，如果能加载则自己加载，以此类推。

 双亲委托机制作用：
1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。

	
Class加载过程：
	1：加载
		类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。
	2：连接（验证、准备和解析）
		当类被加载后就进入连接阶段这一阶段包括以下三个步骤
		2.1 验证
			验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全
		2.2 准备
			为静态变量分配内存并设置默认的初始值
		2.3 解析
			将符号引用替换为直接引用
	3：初始化
		最后 JVM 对类进行初始化，包括：如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类 ；


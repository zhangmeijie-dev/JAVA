                                              接口  <------->  interface    
			接口在编译后也会被编译成Class文件。				接口也可以定义在接口内部   
★★接口的定义格式：									接口也可以定义在类中内部 （跟在内部类相似）

	接口的权限修饰符只有2个 public 和 default（默认的）什么都不写
	abstract 可以省略

	权限修饰符  abstract   interface  接口名 {
		・・・・・・・・・・・・・・・・   ------------------------------>JDK1.7之前接口中只能有    抽象方法 或者   公共的静态常量       


	}                               ------------------------------>JDK1.8以后接口中可以有抽象方法 和公共的静态变量 以及 默认方法  、静态的方法
						默认方法：  权限修饰符   default    返回值  方法名（ 参数列表 ）{  方法体  }    

								-------- 默认方法的权限只有public  并且它的权限只能时public
								-------- 默认方法可以被继承，也可以被重写

						静态方法：  权限修饰符   static    返回值 方法名 （ 参数列表 ）{ 方法体 }  
               
								-------- 权限修饰符只有 public一个（在JDK1.8的时候）
								-------- 静态方法的不可以被继承。（不可以直接访问，需要通过通过接口名直接调用）

			------------------------------>JDK1.9以后接口中可以有     抽象方法    和    公共的静态变量   、  默认方法    、  静态的方法    、  私有的方法       
						静态方法：  权限修饰符   static  返回值  方法名（ 参数列表 ）{ 方法体 }

								------ 静态方法的权限修饰符只有 public 和 private 2个中选择
								------ 静态方法不可以被继承。（不可以被直接调用）
								------ 默认方法不可以使用 private 修饰符

						一般方法：  权限修饰符   返回值  方法名（ 参数列表 ）{ 方法体 }

								------ 一般的方法只能使用 private 修饰符
								------ 一般方法不可以被继承
								


★★接口与接口之间可以多继承   extends   接口名 , 接口名・・・・・・・・・・・・
	如果在被继承的接口之间存在满足方法重写的条件的抽象方法时，只需要自己实现一重写的抽象方法就行。
			          |	
			          |
			          --------->方法名，返回值，参数列表 需要一样   

	如果在被继承的接口之间存在满足方法重写的条件的默认方法时，必须要将该默认方法重写。


				
★★接口与类之间可以多实现    implements     接口名，接口名・・・・・・・・・・・・


★★★（各个版本都一样）接口中的抽象的方法，并且它的修饰符也是固定的  （公共的且非静态的抽象方法）
			----------    格式：  public  abstract  返回值  方法名（）；    public abstract 可以省略  抽象方法默认的就是这  
			----------	 接口中抽象方法的的权限修饰符：只能是 public 


★★★（各个版本都一样）接口中也可以定义成员变量，并且必须为公共的静态的常量，格式如下：（公共的静态的不可修改的变量）
			---------    public static final   数据类型   变量名 = 值；         public static final  可以省略，默认就是这

注意： 
	当多实现时，如果存在有重载的抽象的方法时，我们只需要重写一个即可
	当多实现时，存在有重名的默认方法时，我们需要来重写一次该方法



补充;
	默认方法可以调用接口中的任何方法（静态，私有，一般方法）